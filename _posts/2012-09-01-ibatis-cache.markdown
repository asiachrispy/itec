---
layout: post
title: "ibatis 缓存机制"
tag: "tec"
comment: true
published: true
date: 2012-09-01
---

#	概述
本文主要是对Server端缓存实现机制的调研，给出了ibatis缓存使用方法和使用场景,以及集群环境中的部署说明。

# iBATIS使用介绍
##1. ibatis缓存的类型

主要是用于说明当内存不足时，缓存采取的策略，下面将ibatis中的缓存类型分别说明一下。

#### 1.1 MEMORY类型

这种类型是基于内存的，引用类型分别可以是强引用（STRONG）、软引用（SOFT）、弱引用（WEAK），其中弱引用最常见，适于内存不充足的情况。
强引用是基于传统的Java对象引用机制, 除非对Cache 显式清空(如到了flushInterval设定的时间;执行了flushOnExecute 所指定的方法; 或代码中对 Cache 执行了清除操作等),否则引用将被持续保留。
软引用则不同，当JVM内存不足时，才会对缓冲池中的数据对象进行回收。
而虚引用就更不一样了，当JVM 垃圾回收时,缓存中的数据对象将被JVM收回。

#### 1.2 LRU类型

表示“最近最少使用原则”，也就是说，当内存不足时，缓存会将那些在最近一段时间内使用次数最少的数据清理出内存，而让新的需要缓存的数据写到内存中来。

#### 1.3 FIFO类型

表示“先进先出原则”，是队列数据结构的典型特点,也就是说，当内存不足时，将那些在缓存中驻留时间最长的数据清理出内存。

#### 1.4 OSCACHE类型

OSCACHE是一种缓存开源框架，OSCache提供集群缓存的支持，它使用JavaGroups或JMS作为底层的广播协议。
集群中的每台服务器缓存内容是相互独立的，但是无论何时任何一台服务器中的缓存内容过期，其它的服务器的缓存内容也会认为是过期的；它有自己的配置文件，可以配置广播协议（JavaGroups/JMS），缓存存储类型（内存/磁盘），缓存调度算法（LRU,FIFO 和无限缓存(UnlimitedCache)等信息。

## 2.缓存类型的最佳使用场景

#### 2.1 MEMORY

用户定义的常量数据表，比如字典表，权限表等.

#### 2.2 LRU 

在较长的期间内，用户经常使用某些特定对象,比如用户在检索文档时，经常只查看某些分类的文档，那么这些分类信息就可以使用这个缓存类型。 

#### 2.3 FIFO 

用户在短时间内持续引用特定的查询，而后很可能不再使用，比如用户在某段时间，会比较关注文档的版本信息，而执行相同的查询。  

#### 2.4 OSCACHE

在生产部署时,建议采用 OSCache,OSCache 是得到了广泛使用的开源 Cache 实现(Hibernate 中也提供了对 OSCache 的支持),它基于更加可靠高效的设计,更重要的是,最新版本的 OSCache 已经支持 Cache 集群。如果系统需要部署在集群中,或者需要部署在多机负载均衡模式的环境中以获得性能上的优势,那么 OSCache 在这里则是不二之选。

## 3.缓存实现机制

查询时首先会在缓存中查询是否存在相同的sql语句(使用hashCode计算)，如果不存在，则直接链接数据库，执行查询操作，之后缓存会记录这一次执行的sql语句，作为key存储，返回的结果集作为value存储在缓存；如果当前缓存存在相同的sql语句,则通过这个key值，取得缓存中的结果集，而不需要执行sql语句去查询数据库！
插入操作是无法设置缓存的,也就是说insert 标签没有属性cacheModel,但是是可以干预缓存的。
更新操作是无法设置缓存的,也就是说update 标签没有属性 cacheModel,但是是可以干预缓存的。

## 4. OSCache集群方案介绍
下图给出了一个简单的OSCache集群部署说明，假设Server.1和Server.2是集群中2台服务器，都部署了服务(S1)，S1使用ibatis作为数据持久层框架，使用ibatis的OSCache缓存类型作为S1 Server端查询结果的缓存。

这2台服务之间使用JavaGroups或JMS作为底层的广播协议，集群中的每台服务器缓存内容是相互独立的，但是无论何时任何一台服务器中的缓存内容过期，其它的服务器的缓存内容也会认为是过期的。
